name: Build and Release SZZ Survival Kit

on:
  push:
    paths:
      - 'SZZ_Master_Kit/**'
    branches:
      - main
      - master
  workflow_dispatch:

jobs:
  build:
    name: Build PDF
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          ref: main
          fetch-depth: 0

      - name: Install TeX Live (XeLaTeX & LuaLaTeX)
        run: |
          sudo apt-get update
          sudo apt-get install -y texlive-xetex texlive-luatex texlive-lang-chinese texlive-science latexmk
          # Install Heiti SC equivalent font for Linux (WenQuanYi Micro Hei) to avoid font errors
          sudo apt-get install -y fonts-wqy-microhei xfonts-wqy

      - name: Fix Font Setup (Linux Bypass)
        working-directory: SZZ_Master_Kit
        run: |
          # The document uses Mac fonts (Heiti SC, STSong). On CI (Ubuntu), we must swap them.
          # We will replace them with "WenQuanYi Micro Hei" which we installed above.
          # Using a more robust sed to handle various font calls
          sed -i 's/Heiti SC/WenQuanYi Micro Hei/g' szz_guide.tex
          sed -i 's/STSong/WenQuanYi Micro Hei/g' szz_guide.tex
          sed -i 's/Songti SC/WenQuanYi Micro Hei/g' szz_guide.tex

      - name: Build PDF
        working-directory: SZZ_Master_Kit
        run: |
          # Creating version file if not exists
          if [ ! -f .version ]; then echo "1.0" > .version; fi
          
          # Run make (Note: Makefile uses 'lualatex' as COMPILER variable)
          make build_pdf

      - name: Process Artifacts
        id: get_output
        working-directory: SZZ_Master_Kit
        run: |
          # Find the generated PDF (v*.pdf)
          PDF_FILE=$(ls CVUT_SZZ_Survival_Kit_v*.pdf | head -n 1)
          
          # Create a fixed-name copy for the repository (convenient access)
          cp "$PDF_FILE" CVUT_SZZ_Survival_Kit_latest.pdf
          
          echo "pdf_path=SZZ_Master_Kit/$PDF_FILE" >> $GITHUB_OUTPUT
          echo "repo_pdf_path=SZZ_Master_Kit/CVUT_SZZ_Survival_Kit_latest.pdf" >> $GITHUB_OUTPUT
          echo "pdf_name=$PDF_FILE" >> $GITHUB_OUTPUT
          
          # Extract version for release tag
          VERSION=$(cat .version)
          echo "version=$VERSION" >> $GITHUB_OUTPUT

      - name: Update README with New Version
        run: |
          PDF_NAME="${{ steps.get_output.outputs.pdf_name }}"
          VERSION="${{ steps.get_output.outputs.version }}"
          
          # Update the Download Badge Link to point to the specific Release Asset
          RELEASE_LINK="https://github.com/${{ github.repository }}/releases/download/v${VERSION}/${PDF_NAME}"
          
          # Robust replacement: look for the badge link structure
          # Uses `|` delimiter to avoid escaping slashes
          # Matches: (https://github.com/.../releases...)
          # Replaces with: (${RELEASE_LINK})
          
          sed -i "s|https://github.com/yuanweize/CVUT-SZZ-Survival-Kit/releases)|${RELEASE_LINK})|g" README.md
          
          # Also update the badge text to show version (e.g. PDF-v4.3-blue)
          sed -i "s|badge/PDF-.*-blue|badge/PDF-v${VERSION}-blue|g" README.md

      - name: Commit Version, PDF & README
        run: |
          git config --global user.name "GitHub Actions"
          git config --global user.email "actions@github.com"
          
          # Add the fixed-name PDF, updated version file, and updated README
          git add SZZ_Master_Kit/.version
          git add SZZ_Master_Kit/CVUT_SZZ_Survival_Kit_latest.pdf
          git add README.md
          
          # Check if there are changes to commit
          if git diff --staged --quiet; then
            echo "No changes to commit."
          else
            # 1. Commit local changes first
            git commit -m "chore: release v${{ steps.get_output.outputs.version }} [skip ci]"
            
            # 2. Stash any unstaged changes (e.g., build artifacts) to allow rebase
            git stash
            
            # 3. Pull latest main and rebase our commit on top
            # This handles cases where main updated while we were building
            git pull --rebase origin main
            
            # 4. Push the result
            git push origin main
            
            # Optional: Pop stash if we needed those files (likely not needed for CI)
            # git stash pop || true
          fi

      - name: Create Release
        uses: softprops/action-gh-release@v1
        if: success()
        with:
          tag_name: v${{ steps.get_output.outputs.version }}
          name: SZZ Survival Kit v${{ steps.get_output.outputs.version }}
          files: ${{ steps.get_output.outputs.pdf_path }}
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
