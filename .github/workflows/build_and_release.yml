name: Build and Release SZZ Survival Kit

on:
  push:
    paths:
      - 'SZZ_Master_Kit/**'
    branches:
      - main
      - master
  workflow_dispatch:

jobs:
  build:
    name: Build PDF
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          ref: main
          fetch-depth: 0

      - name: Install TeX Live (XeLaTeX & LuaLaTeX)
        run: |
          sudo apt-get update
          sudo apt-get install -y texlive-xetex texlive-luatex texlive-lang-chinese texlive-science latexmk
          # Install Heiti SC equivalent font for Linux (WenQuanYi Micro Hei) to avoid font errors
          sudo apt-get install -y fonts-wqy-microhei xfonts-wqy

      - name: Fix Font Setup (Linux Bypass)
        working-directory: SZZ_Master_Kit
        run: |
          # The document uses Mac fonts (Heiti SC, STSong). On CI (Ubuntu), we must swap them.
          # We will replace them with "WenQuanYi Micro Hei" which we installed above.
          # Using a more robust sed to handle various font calls
          sed -i 's/Heiti SC/WenQuanYi Micro Hei/g' szz_guide.tex
          sed -i 's/STSong/WenQuanYi Micro Hei/g' szz_guide.tex
          sed -i 's/Songti SC/WenQuanYi Micro Hei/g' szz_guide.tex

      - name: Build PDF
        working-directory: SZZ_Master_Kit
        run: |
          # Clean up any existing versioned PDFs to avoid confusion
          rm -f CVUT_SZZ_Survival_Kit_v*.pdf
          
          # Creating version file if not exists
          if [ ! -f .version ]; then echo "1.0" > .version; fi
          
          # Run make (Note: Makefile uses 'lualatex' as COMPILER variable)
          make build_pdf

      - name: Process Artifacts
        id: get_output
        working-directory: SZZ_Master_Kit
        run: |
          # Extract version for release tag (The Single Source of Truth)
          VERSION=$(cat .version)
          
          # Construct the expected PDF filename explicitly
          PDF_FILE="CVUT_SZZ_Survival_Kit_v${VERSION}.pdf"
          
          # Verify the file actually exists
          if [ ! -f "$PDF_FILE" ]; then
            echo "Error: Expected output file $PDF_FILE not found!"
            exit 1
          fi
          
          # Create a fixed-name copy for the repository (convenient access)
          cp "$PDF_FILE" CVUT_SZZ_Survival_Kit_latest.pdf
          
          echo "pdf_path=SZZ_Master_Kit/$PDF_FILE" >> $GITHUB_OUTPUT
          echo "repo_pdf_path=SZZ_Master_Kit/CVUT_SZZ_Survival_Kit_latest.pdf" >> $GITHUB_OUTPUT
          echo "pdf_name=$PDF_FILE" >> $GITHUB_OUTPUT
          echo "version=$VERSION" >> $GITHUB_OUTPUT

      - name: Update README with New Version
        run: |
          VERSION="${{ steps.get_output.outputs.version }}"
          
          # Only update the badge text to reflect the new version
          # Pattern matches: badge/Download-SZZ_Survival_Kit_(v.*)-2ea44f
          # We update the version part to (vX.X)
          sed -i "s|SZZ_Survival_Kit_(.*)-2ea44f|SZZ_Survival_Kit_(v${VERSION})-2ea44f|g" README.md
          
          # Legacy/Fallback cleanup (if any)
          sed -i "s|badge/PDF-.*-blue|badge/Download-SZZ_Survival_Kit_(v${VERSION})-2ea44f|g" README.md

      - name: Commit Version, PDF & README
        run: |
          git config --global user.name "GitHub Actions"
          git config --global user.email "actions@github.com"
          
          # Add the fixed-name PDF, updated version file, and updated README
          git add SZZ_Master_Kit/.version
          git add SZZ_Master_Kit/CVUT_SZZ_Survival_Kit_latest.pdf
          git add README.md
          
          # Check if there are changes to commit
          if git diff --staged --quiet; then
            echo "No changes to commit."
          else
            # 1. Commit local changes first
            git commit -m "chore: release v${{ steps.get_output.outputs.version }} [skip ci]"
            
            # 2. Stash any unstaged changes (e.g., build artifacts) to allow rebase
            git stash
            
            # 3. Pull latest main and rebase our commit on top
            # This handles cases where main updated while we were building
            git pull --rebase origin main
            
            # 4. Push the result
            git push origin main
            
            # Optional: Pop stash if we needed those files (likely not needed for CI)
            # git stash pop || true
          fi

      - name: Create Release
        uses: softprops/action-gh-release@v1
        if: success()
        with:
          tag_name: v${{ steps.get_output.outputs.version }}
          name: SZZ Survival Kit v${{ steps.get_output.outputs.version }}
          files: ${{ steps.get_output.outputs.pdf_path }}
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
